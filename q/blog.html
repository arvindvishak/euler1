<a title="q" href="http://en.wikipedia.org/wiki/Q_(equational_programming_language)">Q</a>, introduced in 1991, is a programming language designed to manipulate mathematical equations. Its author, Albert Gräf, has since updated it with a more full-featured replacement, the language <a title="pure" href="http://gdm9000.wordpress.com/2013/05/26/pure/">Pure</a>. Here is an example of <a title="Euler1" href="http://projecteuler.net/problem=1">Euler1</a> in Q using a <a title="list comprehension" href="http://en.wikipedia.org/wiki/List_comprehension">list comprehension</a>:
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><em><span style="color: #007788;">#!/usr/bin/q -c main
// Euler1 in Q</span> </em>

<span style="color: #cc00ff;">euler1</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> sum [<span style="color: #007788; font-weight: bold;">X</span> <span style="color: #007788; font-weight: bold;">:</span> <span style="color: #007788; font-weight: bold;">X</span> <span style="color: #006699; font-weight: bold;">in</span> [<span style="color: #ff6600;">1</span><span style="color: #555555;">..</span><span style="color: #007788; font-weight: bold;">N</span>], (<span style="color: #007788; font-weight: bold;">X</span> mod <span style="color: #ff6600;">3</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>) <span style="color: #006699; font-weight: bold;">or else</span> (<span style="color: #007788; font-weight: bold;">X</span> mod <span style="color: #ff6600;">5</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>)];

<span style="color: #cc00ff;">main</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">write</span> (euler1 <span style="color: #ff6600;">999</span>);</pre>
</div>
Q has full support for functional operations. Here’s an example using the canonical functions <em><a title="map" href="http://en.wikipedia.org/wiki/Map_(higher-order_function)">map</a>, <a title="filter" href="http://en.wikipedia.org/wiki/Filter_(higher-order_function)">filter</a></em>, and <em><a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">fold</a></em>. Map’s only purpose here obviously is for illustration, since it returns itself. It also demonstrates use of <a title="lambda" href="http://en.wikipedia.org/wiki/Anonymous_function">lambda</a> - an anonymous inline function using the \ operator, and <a title="function composition" href="http://en.wikipedia.org/wiki/Function_composition">function composition</a>, where we chain together our three functions with the <em>.</em> operator:
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><em><span style="color: #007788;">#!/usr/bin/q -c main
// Euler1 in Q</span> </em>

<span style="color: #cc00ff;">myMap</span>    <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> map id <span style="color: #007788; font-weight: bold;">Xs</span>;
<span style="color: #cc00ff;">myFilter</span> <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> filter (<span style="color: #cc00ff;">\</span><span style="color: #007788; font-weight: bold;">X</span><span style="color: #555555;">.</span>(<span style="color: #007788; font-weight: bold;">X</span> mod <span style="color: #ff6600;">3</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>) <span style="color: #006699; font-weight: bold;">or else</span> (<span style="color: #007788; font-weight: bold;">X</span> mod <span style="color: #ff6600;">5</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>)) <span style="color: #007788; font-weight: bold;">Xs</span>;
<span style="color: #cc00ff;">myFold</span>   <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> foldl (<span style="color: #555555;">+</span>) <span style="color: #ff6600;">0</span> <span style="color: #007788; font-weight: bold;">Xs</span>;

<span style="color: #cc00ff;">euler1</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> (myFold<span style="color: #555555;">.</span>myFilter<span style="color: #555555;">.</span>myMap) [<span style="color: #ff6600;">1</span><span style="color: #555555;">..</span><span style="color: #007788; font-weight: bold;">N</span>];

<span style="color: #cc00ff;">main</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">write</span> (euler1 <span style="color: #ff6600;">999</span>);</pre>
</div>
Notice that we are not maintaining any state to solve our problem. No loops, no variables, no mutable state - only function application. We simply call map, filter, and fold, and get the solution. This is an important part of the solution of the concurrency problem – how do you keep threads from stepping on each other’s states? By eliminating mutable state!

Next is a functional version that uses <a title="TailRecursion" href="http://stackoverflow.com/questions/33923/what-is-tail-recursion">tail recursion</a> with an accumulator. One of the main points here is that the function <em>euler</em> is <a title="Determinism" href="http://en.wikipedia.org/wiki/Deterministic_algorithm">deterministic</a> – it will always return the same output for a given input. This is accomplished in part by the absence of any variable manipulation – there are instead only functions which return values. The other main point is that this recursion uses tail call optimization – it’s written in such a way that an intelligent compiler can optimize its stack usage to be <a title="big o notation" href="http://en.wikipedia.org/wiki/Big_O_notation"><em>O(n)</em> instead of<em> O(n!)</em></a>. In English, this means that your program will probably not crash even for hugely recursive calls.
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><em><span style="color: #007788;">#!/usr/bin/q -c main
// Euler1 in Q</span> </em>

<span style="color: #cc00ff;">mod_3_5</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #006699; font-weight: bold;">if</span> <span style="color: #007788; font-weight: bold;">N</span> mod <span style="color: #ff6600;">3</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>;
          <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #006699; font-weight: bold;">if</span> <span style="color: #007788; font-weight: bold;">N</span> mod <span style="color: #ff6600;">5</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>;
          <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>;

<span style="color: #cc00ff;">euler</span> <span style="color: #ff6600;">0</span> <span style="color: #007788; font-weight: bold;">Acc</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">Acc</span>;
<span style="color: #cc00ff;">euler</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #007788; font-weight: bold;">Acc</span> <span style="color: #000000; font-weight: bold;">=</span> euler (<span style="color: #007788; font-weight: bold;">N</span><span style="color: #555555;">-</span><span style="color: #ff6600;">1</span>) (<span style="color: #007788; font-weight: bold;">Acc</span><span style="color: #555555;">+</span><span style="color: #007788; font-weight: bold;">N</span>)  <span style="color: #006699; font-weight: bold;">if</span> mod_3_5 <span style="color: #007788; font-weight: bold;">N</span>;
            <span style="color: #000000; font-weight: bold;">=</span> euler (<span style="color: #007788; font-weight: bold;">N</span><span style="color: #555555;">-</span><span style="color: #ff6600;">1</span>)  <span style="color: #007788; font-weight: bold;">Acc</span>     otherwise;

<span style="color: #cc00ff;">euler1</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> euler <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #ff6600;">0</span>;

<span style="color: #cc00ff;">main</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">write</span> (euler1 <span style="color: #ff6600;">999</span>);</pre>
</div>
Here, our function <em>euler</em>  takes two parameters, but we wrap it in an outer function using the <em>with</em> keyword so that we can expose a simpler signature <em>euler1</em> having only one parameter. Unlike imperative languages, which require each function to have a unique signature, Q allows multiple instances having the same signature. The runtime uses <em>pattern matching</em> and <em>guards</em> to resolve which instance to call. When a function is called, the runtime checks all functions with a given name, and starting at the top of the code and working down, it finds the first function that matches and executes that. Obviously then, you'll need to order your functions from most restrictive to least.

With pattern matching, not only does the runtime match parameter types, but it matches parameter values. If the first parameter has value 0, it calls the first function, else it calls the second. Obviously, the version with <em>0</em> needs to be listed first; if the version with <em>n</em> was listed first, the runtime would always choose it:
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><em></em><span style="color: #cc00ff;">euler</span> <em><strong><span style="color: #ff0000;">0 Acc</span></strong></em> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">Acc</span>;
<span style="color: #cc00ff;">euler</span> <em><span style="color: #ff0000;"><span style="font-weight: bold;">N</span> <span style="font-weight: bold;">Acc</span></span></em> <span style="color: #000000; font-weight: bold;">=</span> euler (<span style="color: #007788; font-weight: bold;">N</span><span style="color: #555555;">-</span><span style="color: #ff6600;">1</span>) (<span style="color: #007788; font-weight: bold;">Acc</span><span style="color: #555555;">+</span><span style="color: #007788; font-weight: bold;">N</span>)  <span style="color: #006699; font-weight: bold;">if</span> (<span style="color: #007788; font-weight: bold;">N</span> mod <span style="color: #ff6600;">3</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>) <span style="color: #006699; font-weight: bold;">or else</span> (<span style="color: #007788; font-weight: bold;">N</span> mod <span style="color: #ff6600;">5</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>);</pre>
</div>
Guards are additional checks against parameters. Here a guard is added to assert that <em>n</em> be divisible by 3 and 5. Again, obviously, this version must be listed first:
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #cc00ff;">mod_3_5</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">N</span> <strong><em><span style="color: #ff0000;">if N mod 3 = 0</span></em></strong>;
          <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">N</span> <strong><em><span style="color: #ff0000;">if N mod 5 = 0</span></em></strong>;
          <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>;</pre>
</div>
Q's native data structure is the <a title="linked list" href="https://en.wikipedia.org/wiki/Linked_list">linked list</a>. Here's an example where we work with lists. Let's modify the internal <em>euler</em> above to take two arguments - a list of functions and a list of ints. Each recursive call to <em>euler</em> will peel off another function from the list and apply it to the ints. Here, the first version of <em>euler</em> matches an empty list of functions, and whose job is to simply return the last calculated value. The function list in the other version is symbolized as <em>[F|Fs]</em>, where <em>F</em> matches the first item in the list, and <em>Fs</em> matches to the rest of the list:
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><em><span style="color: #007788;">#!/usr/bin/q -c main
// Euler1 in Q</span> </em>

<span style="color: #cc00ff;">myMap</span>    <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> map id <span style="color: #007788; font-weight: bold;">Xs</span>;
<span style="color: #cc00ff;">myFilter</span> <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> filter (<span style="color: #cc00ff;">\</span><span style="color: #007788; font-weight: bold;">X</span><span style="color: #555555;">.</span>(<span style="color: #007788; font-weight: bold;">X</span> mod <span style="color: #ff6600;">3</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>) <span style="color: #006699; font-weight: bold;">or else</span> (<span style="color: #007788; font-weight: bold;">X</span> mod <span style="color: #ff6600;">5</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>)) <span style="color: #007788; font-weight: bold;">Xs</span>;
<span style="color: #cc00ff;">myFold</span>   <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> foldl (<span style="color: #555555;">+</span>) <span style="color: #ff6600;">0</span> <span style="color: #007788; font-weight: bold;">Xs</span>;

<span style="color: #cc00ff;">euler</span> <span style="color: #007788; font-weight: bold;">[]</span>     <span style="color: #007788; font-weight: bold;">X</span>  <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">X</span>;
<span style="color: #cc00ff;">euler</span> [<span style="color: #007788; font-weight: bold;">F</span><span style="color: #555555;">|</span><span style="color: #007788; font-weight: bold;">Fs</span>] <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> euler <span style="color: #007788; font-weight: bold;">Fs</span> (<span style="color: #007788; font-weight: bold;">F</span> <span style="color: #007788; font-weight: bold;">Xs</span>);

<span style="color: #cc00ff;">euler1</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> euler [myMap,myFilter,myFold] [<span style="color: #ff6600;">1</span><span style="color: #555555;">..</span><span style="color: #007788; font-weight: bold;">N</span>];

<span style="color: #cc00ff;">main</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">write</span> (euler1 <span style="color: #ff6600;">999</span>);</pre>
</div>
Here’s another version using a <a title="Quicksort" href="http://en.wikipedia.org/wiki/Quicksort">Quicksort</a>-based algorithm. Here we recursively break the list up in half and then reassemble it. Instead of sorting each half, though, we’ll filter the pivot value, converting it to 0 if it’s not divisible. Here, e<em>uler </em>returns e<em>uler</em> calculated on the half of the list before the pivot element, e<em>uler</em> calculated on the half of the list after the pivot element, and the pivot element or 0, all added together. It demonstrates some of Q's string operations such as slicing:
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><em><span style="color: #007788;">#!/usr/bin/q -c main
// Euler1 in Q</span> </em>

<span style="color: #cc00ff;">mod_3_5</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #006699; font-weight: bold;">if</span> (<span style="color: #007788; font-weight: bold;">N</span> mod <span style="color: #ff6600;">3</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>);
          <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #006699; font-weight: bold;">if</span> (<span style="color: #007788; font-weight: bold;">N</span> mod <span style="color: #ff6600;">5</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>);
          <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>;

<em><span style="color: #007788;">// the midpoint of the list</span></em>
<span style="color: #cc00ff;">mid</span>  <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> trunc(<span style="color: #555555;">#</span><span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #555555;">/</span> <span style="color: #ff6600;">2</span>);
<em><span style="color: #007788;">// return a value for the midpoint element</span></em>
<span style="color: #cc00ff;">val</span>  <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> mod_3_5 (<span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #555555;">!</span> mid <span style="color: #007788; font-weight: bold;">Xs</span>);
<em><span style="color: #007788;">// plus euler on the first half of the list</span></em>
<span style="color: #cc00ff;">pre</span>  <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> sub <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #ff6600;">0</span> ((mid <span style="color: #007788; font-weight: bold;">Xs</span>)<span style="color: #555555;">-</span><span style="color: #ff6600;">1</span>);
<em><span style="color: #007788;">// plus euler on the last half of the list</span></em>
<span style="color: #cc00ff;">post</span> <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> sub <span style="color: #007788; font-weight: bold;">Xs</span> ((mid <span style="color: #007788; font-weight: bold;">Xs</span>)<span style="color: #555555;">+</span><span style="color: #ff6600;">1</span>) (<span style="color: #555555;">#</span><span style="color: #007788; font-weight: bold;">Xs</span>);

<span style="color: #cc00ff;">euler</span> <span style="color: #007788; font-weight: bold;">[]</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #ff6600;">0</span>;
<span style="color: #cc00ff;">euler</span> <span style="color: #007788; font-weight: bold;">Xs</span> <span style="color: #000000; font-weight: bold;">=</span> euler(pre <span style="color: #007788; font-weight: bold;">Xs</span>) <span style="color: #555555;">+</span> (val <span style="color: #007788; font-weight: bold;">Xs</span>) <span style="color: #555555;">+</span> euler(post <span style="color: #007788; font-weight: bold;">Xs</span>);

<span style="color: #cc00ff;">euler1</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> euler [<span style="color: #ff6600;">1</span><span style="color: #555555;">..</span><span style="color: #007788; font-weight: bold;">N</span>];

<span style="color: #cc00ff;">main</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">write</span> (euler1 <span style="color: #ff6600;">999</span>);</pre>
</div>
I'm a little concerned with this version's efficiency - you can see that for every call to <em>euler xs</em>, <em>mid xs</em> gets called three times - by <em>pre, val</em>, and <em>post</em>. I can't put it in a local variable since I only have a collection of functions. I'm not sure how the compiler or runtime will optimize this.

Here’s one more – an elegant algorithm based on an observation by little Carl Friedrich Gauss – <a href="http://blog.smoothfriction.nl/archive/2011/01/23/powershell-fun-project-euler-1-gauss-being-smart.aspx">http://blog.smoothfriction.nl/archive/2011/01/23/powershell-fun-project-euler-1-gauss-being-smart.aspx</a>. It operates in <a title="Time complexity" href="http://en.wikipedia.org/wiki/Time_complexity">O(1) constant time</a>. Don’t sweat it if this seems inscrutable; click the blog link above for an explanation.
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><em><span style="color: #007788;">#!/usr/bin/q -c main
// Euler1 in Q</span> </em>

<span style="color: #cc00ff;">mySum</span> <span style="color: #007788; font-weight: bold;">Size</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> trunc (<span style="color: #007788; font-weight: bold;">N</span> <span style="color: #555555;">*</span> (floor(<span style="color: #007788; font-weight: bold;">Size</span><span style="color: #555555;">/</span><span style="color: #007788; font-weight: bold;">N</span>)<span style="color: #555555;">^</span><span style="color: #ff6600;">2</span> <span style="color: #555555;">+</span> floor(<span style="color: #007788; font-weight: bold;">Size</span><span style="color: #555555;">/</span><span style="color: #007788; font-weight: bold;">N</span>)) <span style="color: #555555;">/</span> <span style="color: #ff6600;">2</span>);

<span style="color: #cc00ff;">euler1</span> <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #000000; font-weight: bold;">=</span> mySum <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #ff6600;">3</span> <span style="color: #555555;">+</span> mySum <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #ff6600;">5</span> <span style="color: #555555;">-</span> mySum <span style="color: #007788; font-weight: bold;">N</span> <span style="color: #ff6600;">15</span>;

<span style="color: #cc00ff;">main</span> <span style="color: #000000; font-weight: bold;">=</span> <span style="color: #007788; font-weight: bold;">write</span> (euler1 <span style="color: #ff6600;">999</span>);</pre>
</div>
Q has more interesting math-oriented functionality, like full support for matrix operations and a macro system that does symbol substitution instead of the traditional textual substitution.

The weirdest part of Q is its support for undefined symbols. The runtime lets you define algebraic formulas with undefined symbols on the right-hand side. This isn't allowed in imperative languages, but Q is perfectly happy dealing with the abstract. Here, we define function <em>foo</em> equal to the sum of some undefined symbols, and when we ask the runtime for <em>foo's</em> value, it returns an <em>equation</em>:
<div style="background: #f0f3f3; overflow: auto; width: auto; margin-bottom: 20px; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;">==&gt; foo = a + b + c;
foo=a+b+c

==&gt;</pre>
</div>
So be careful - if you try to pass the wrong type to a function, its pattern matching will see that no function signature exists with that type, the runtime will simply create a new symbol (symbolic) instance of that signature. The new symbol has no value, but the runtime doesn't care! Expect to pull out some of your hair wondering why your program doesn't produce expected results. Actually, like most new languages, Q has a great <a title="repl" href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> for debugging that you're going to want to make friends with.

Overall, I had a lot of fun with Q and would recommend it for those looking to expand their horizons. To kick the tires on the language and run your program from the command-line, simply yum-install q, then pass your file as an argument to the runtime as well as a function to call:
<div style="background: black; overflow: auto; width: auto; color: white; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #ffffff;">$</span> q <span style="color: #ffffff;">euler1.q -c main</span>
<span style="color: #0086f7; font-weight: bold;">233168()</span>
<span style="color: #ffffff;">$</span></pre>
</div>